<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>오목 (Gomoku) - 웹 버전</title>
  <style>
    :root {
      --board-size: 15; /* 기본 15x15 */
      --cell: 36px;     /* 한 칸 크기 */
      --line-color: #8b5a2b;
      --board-bg: #f0d9b5;
      --stone-black: #111;
      --stone-white: #fafafa;
      --accent: #2563eb;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 16px; background: #0b1020; color: #e6eaf2;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple SD Gothic Neo, Noto Sans KR, "Malgun Gothic", sans-serif;
      display: grid; place-items: start center; gap: 16px;
    }
    h1 { margin: 0 0 8px; font-size: 20px; font-weight: 700; letter-spacing: 0.2px; }

    .app {
      width: min(96vw, 860px);
      display: grid; gap: 12px;
    }

    .panel {
      display: grid; gap: 8px; grid-template-columns: 1fr auto auto auto; align-items: center;
      background: #121a33; border: 1px solid #1f294a; border-radius: 12px; padding: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);
    }
    .panel .group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    label { font-size: 14px; opacity: .9; }
    select, button {
      background: #172046; color: #e6eaf2; border: 1px solid #2a386d; border-radius: 10px;
      padding: 8px 12px; font-size: 14px; cursor: pointer; outline: none;
    }
    button:hover { border-color: #3b57b6; }
    button.primary { background: #2441c2; border-color: #3252e0; }
    button.primary:hover { background: #2a4ae0; }

    .status {
      margin-top: 2px; font-size: 14px; opacity: .95; display: flex; align-items: center; gap: 10px;
    }
    .badge { padding: 2px 8px; border-radius: 999px; background: #1c2a55; border: 1px solid #2a386d; font-size: 12px; }

    /* 보드 컨테이너 */
    .board-wrap { display: grid; place-items: center; }
    .board {
      position: relative;
      width: calc(var(--cell) * var(--board-size));
      height: calc(var(--cell) * var(--board-size));
      background: var(--board-bg);
      border: 10px solid #7a4b1e; border-radius: 12px;
      box-shadow: 0 20px 50px rgba(0,0,0,.35);
      image-rendering: pixelated;
      /* 바둑판 격자선: 반복 배경그라디언트 2개 */
      background-image:
        linear-gradient(to right, var(--line-color) 1px, transparent 1px),
        linear-gradient(to bottom, var(--line-color) 1px, transparent 1px);
      background-size: var(--cell) var(--cell), var(--cell) var(--cell);
      background-position: center center;
      display: grid;
      grid-template-columns: repeat(var(--board-size), var(--cell));
      grid-template-rows: repeat(var(--board-size), var(--cell));
    }

    .cell {
      position: relative;
      width: var(--cell); height: var(--cell);
    }

    .stone {
      position: absolute; inset: 0;
      display: grid; place-items: center;
    }

    .stone::after {
      content: "";
      width: calc(var(--cell) * .76);
      height: calc(var(--cell) * .76);
      border-radius: 50%;
      box-shadow: inset 0 -2px 4px rgba(0,0,0,.35), inset 0 2px 6px rgba(255,255,255,.15);
      transform: translateZ(0);
    }

    .black::after { background: radial-gradient(circle at 35% 30%, #333, var(--stone-black)); }
    .white::after { background: radial-gradient(circle at 35% 30%, #fff, var(--stone-white)); box-shadow: inset 0 -2px 4px rgba(0,0,0,.25), inset 0 2px 6px rgba(255,255,255,.45), 0 0 0 1px rgba(0,0,0,.2); }

    /* 마지막 수 하이라이트 */
    .last::after { outline: 3px solid var(--accent); outline-offset: -3px; }

    /* 승리 라인 강조 */
    .win::after { box-shadow: 0 0 0 3px #34d399, inset 0 -2px 4px rgba(0,0,0,.35), inset 0 2px 6px rgba(255,255,255,.15) !important; }

    /* 반응형: 화면이 작을 때 칸 크기 축소 */
    @media (max-width: 700px) {
      :root { --cell: 28px; }
    }
    @media (max-width: 480px) {
      :root { --cell: 24px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>오목 (Gomoku) – 브라우저 버전</h1>
    <div class="panel">
      <div class="group">
        <label for="mode">모드</label>
        <select id="mode" title="게임 모드">
          <option value="pvp">사람 vs 사람</option>
          <option value="pve" selected>사람 vs CPU</option>
        </select>
        <label for="size">보드</label>
        <select id="size" title="보드 크기">
          <option value="15" selected>15 x 15</option>
          <option value="19">19 x 19</option>
          <option value="13">13 x 13</option>
        </select>
      </div>
      <div class="group">
        <button id="new" class="primary">새 게임</button>
        <button id="undo">되돌리기</button>
      </div>
      <div class="status">
        <span class="badge" id="turnBadge">흑(X) 차례</span>
        <span id="statusText">시작합니다. 칸을 클릭하여 착수하세요.</span>
      </div>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" role="grid" aria-label="오목판"></div>
    </div>
  </div>

  <script>
    // ================== 게임 설정 & 상태 ==================
    const DIRECTIONS = [
      [1, 0],  // 세로
      [0, 1],  // 가로
      [1, 1],  // 대각 ↘
      [1, -1], // 대각 ↗
    ];

    let size = 15;
    let board = [];
    let current = 1; // 1=흑(X), 2=백(O)
    let gameOver = false;
    let lastMove = null; // {r,c}
    let history = []; // 착수 스택 [{r,c,player}]

    const elBoard = document.getElementById('board');
    const elMode  = document.getElementById('mode');
    const elSize  = document.getElementById('size');
    const elNew   = document.getElementById('new');
    const elUndo  = document.getElementById('undo');
    const elTurn  = document.getElementById('turnBadge');
    const elStatus= document.getElementById('statusText');

    function setCSSBoardSize(n) {
      document.documentElement.style.setProperty('--board-size', n);
    }

    function newBoard(n) {
      size = n;
      setCSSBoardSize(size);
      board = Array.from({ length: size }, () => Array(size).fill(0));
      current = 1;
      gameOver = false;
      lastMove = null;
      history = [];
      elBoard.innerHTML = '';
      renderBoard();
      updateTurnBadge();
      elStatus.textContent = '시작합니다. 칸을 클릭하여 착수하세요.';
    }

    function renderBoard() {
      // 격자를 HTML로 렌더링
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;

          const stone = document.createElement('div');
          stone.className = 'stone';
          cell.appendChild(stone);

          cell.addEventListener('click', onCellClick);
          elBoard.appendChild(cell);
        }
      }
    }

    function onCellClick(e) {
      if (gameOver) return;
      const cell = e.currentTarget;
      const r = +cell.dataset.r;
      const c = +cell.dataset.c;
      if (board[r][c] !== 0) return; // 이미 둔 자리

      placeStone(r, c, current, true);

      const mode = elMode.value;
      if (!gameOver && mode === 'pve' && current === 2) {
        // 사람은 항상 흑(1)으로 시작. 흑이 둔 뒤 current는 2(백=CPU)가 됨.
        setTimeout(cpuTurn, 60);
      }
    }

    function placeStone(r, c, player, pushHistory) {
      board[r][c] = player;
      if (pushHistory) history.push({ r, c, player });
      paintStone(r, c, player);
      markLast(r, c);

      const winInfo = checkWin(r, c, player);
      if (winInfo.win) {
        highlightWin(winInfo.cells);
        elStatus.textContent = `${player === 1 ? '흑(X)' : '백(O)'} 승리!`;
        gameOver = true;
        return;
      }
      if (isFull()) {
        elStatus.textContent = '무승부입니다.';
        gameOver = true;
        return;
      }
      // 턴 전환
      current = (player === 1) ? 2 : 1;
      updateTurnBadge();
    }

    function paintStone(r, c, player) {
      const idx = r * size + c;
      const cell = elBoard.children[idx];
      const stone = cell.querySelector('.stone');
      stone.classList.remove('black', 'white', 'last', 'win');
      stone.classList.add(player === 1 ? 'black' : 'white');
    }

    function markLast(r, c) {
      if (lastMove) {
        const prevIdx = lastMove.r * size + lastMove.c;
        elBoard.children[prevIdx].querySelector('.stone').classList.remove('last');
      }
      const idx = r * size + c;
      elBoard.children[idx].querySelector('.stone').classList.add('last');
      lastMove = { r, c };
    }

    function highlightWin(cells) {
      for (const { r, c } of cells) {
        const idx = r * size + c;
        elBoard.children[idx].querySelector('.stone').classList.add('win');
      }
    }

    function updateTurnBadge() {
      elTurn.textContent = `${current === 1 ? '흑(X)' : '백(O)'} 차례`;
    }

    function isFull() {
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (board[r][c] === 0) return false;
        }
      }
      return true;
    }

    function inBounds(r, c) {
      return r >= 0 && c >= 0 && r < size && c < size;
    }

    function checkWin(r, c, player) {
      for (const [dr, dc] of DIRECTIONS) {
        let cells = [{ r, c }];
        // forward
        let rr = r + dr, cc = c + dc;
        while (inBounds(rr, cc) && board[rr][cc] === player) {
          cells.push({ r: rr, c: cc });
          rr += dr; cc += dc;
        }
        // backward
        rr = r - dr; cc = c - dc;
        while (inBounds(rr, cc) && board[rr][cc] === player) {
          cells.unshift({ r: rr, c: cc });
          rr -= dr; cc -= dc;
        }
        if (cells.length >= 5) {
          return { win: true, cells };
        }
      }
      return { win: false, cells: [] };
    }

    // ================== 되돌리기 ==================
    function undo() {
      if (history.length === 0 || gameOver && history.length === 0) return;
      const mode = elMode.value;

      const undoOnce = () => {
        const last = history.pop();
        if (!last) return;
        board[last.r][last.c] = 0;
        const idx = last.r * size + last.c;
        const stone = elBoard.children[idx].querySelector('.stone');
        stone.className = 'stone';
        // 마지막 수 표시 재계산
        lastMove = history.length ? history[history.length - 1] : null;
        for (let i = 0; i < elBoard.children.length; i++) {
          elBoard.children[i].querySelector('.stone').classList.remove('last', 'win');
        }
        if (lastMove) {
          const prevIdx = lastMove.r * size + lastMove.c;
          elBoard.children[prevIdx].querySelector('.stone').classList.add('last');
        }
        gameOver = false;
        current = last.player; // 방금 취소한 플레이어의 차례로
        updateTurnBadge();
        elStatus.textContent = '되돌렸습니다.';
      };

      if (mode === 'pve') {
        // 사람+CPU 한 묶음 되돌리기 (가능하면 2수 취소)
        undoOnce();
        if (history.length && history[history.length - 1].player === 1) {
          undoOnce();
        }
      } else {
        undoOnce();
      }
    }

    // ================== CPU 간단 로직 ==================
    function cpuTurn() {
      if (gameOver) return;
      const move = cpuMove();
      if (!move) return; // 안전장치
      placeStone(move.r, move.c, 2, true);
    }

    function cpuMove() {
      // 1) 즉시 이기는 수
      let mv = findWinningMove(2);
      if (mv) return mv;
      // 2) 상대(흑)의 즉승 차단
      mv = findWinningMove(1);
      if (mv) return mv;
      // 3) 주변 후보 중 점수 높은 수
      const candidates = neighborEmpties(2);
      let best = null, bestScore = -1e9;
      for (const { r, c } of candidates) {
        const s = scoreCell(r, c, 2);
        if (s > bestScore) { best = { r, c }; bestScore = s; }
      }
      if (best) return best;
      // 4) 완전 비상: 아무 빈칸
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) if (board[r][c] === 0) return { r, c };
      }
      return null;
    }

    function findWinningMove(player) {
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (board[r][c] !== 0) continue;
          board[r][c] = player;
          const win = checkWin(r, c, player).win;
          board[r][c] = 0;
          if (win) return { r, c };
        }
      }
      return null;
    }

    function neighborEmpties(radius = 2) {
      const set = new Set();
      let any = false;
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          if (board[r][c] !== 0) {
            any = true;
            for (let dr = -radius; dr <= radius; dr++) {
              for (let dc = -radius; dc <= radius; dc++) {
                const rr = r + dr, cc = c + dc;
                if (inBounds(rr, cc) && board[rr][cc] === 0) set.add(rr + "," + cc);
              }
            }
          }
        }
      }
      if (!any) {
        const mid = Math.floor(size / 2);
        return [{ r: mid, c: mid }];
      }
      return [...set].map(s => { const [r, c] = s.split(',').map(Number); return { r, c }; });
    }

    function scoreCell(r, c, player) {
      // 간단 휴리스틱: 내 연장 + 상대 차단 + 중앙 가중치
      const opp = player === 1 ? 2 : 1;
      let score = 0;
      for (const [dr, dc] of DIRECTIONS) {
        score += potentialLine(r, c, dr, dc, player) * 6; // 내 연결 강화
        score += potentialLine(r, c, dr, dc, opp) * 5;    // 상대 연결 차단
      }
      const center = Math.floor(size / 2);
      score += (size - Math.abs(r - center) - Math.abs(c - center));
      return score;
    }

    function potentialLine(r, c, dr, dc, player) {
      let cnt = 0;
      let rr = r + dr, cc = c + dc;
      while (inBounds(rr, cc) && board[rr][cc] === player) { cnt++; rr += dr; cc += dc; }
      rr = r - dr; cc = c - dc;
      while (inBounds(rr, cc) && board[rr][cc] === player) { cnt++; rr -= dr; cc -= dc; }
      return cnt;
    }

    // ================== 이벤트 & 초기화 ==================
    elNew.addEventListener('click', () => {
      newBoard(+elSize.value);
    });

    elUndo.addEventListener('click', () => {
      undo();
    });

    elSize.addEventListener('change', () => {
      newBoard(+elSize.value);
    });

    elMode.addEventListener('change', () => {
      // 모드 바뀌어도 진행 중인 게임 유지, 메시지만 갱신
      if (!gameOver) updateTurnBadge();
    });

    // 첫 로드
    newBoard(size);
  </script>
</body>
</html>
